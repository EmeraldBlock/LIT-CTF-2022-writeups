# rev/minimalist

## Challenge

less is more

[minimalist](https://drive.google.com/uc?export=download&id=1vMY6FRx_Eff2ypd9vaZCRr6HYNdPsneX)

## Solution
Running it confirms it's a flag checker:
```
Enter the flag: 
idk
asdfasdfasdfasdfasdfasdf
asdfasdfasdfasdf
asdfasdf
Wrong flag!
```
(Being able to input multiple lines suggests it reads char-by-char.)

Let's disassemble the executable! ...oh it's got a lot of stuff.

Note the text "Enter the flag" is contained at `2004`, which is referenced at `11b7`, so that's around where things start.
Further down it gets ugly, with a ton of bitwise instructions and what appear to be loops. But there are two more external references, to `41e0` and `4060`, both in the `.data` section, and both seem to be arrays of ints, with start and end quite obvious.

Let's line up the bits of the 0th entry of each array with `L`, which should be the first character of the flag:
```
41e0: 87ffffff ffffffff -> ...10000111
4060: 34000000 00000000 -> ...00110100
 'L':                         01001100
```
Nice, it's just a NXOR. This also means the upper bits just result in 0 and are ignorable.
Let's just copy the rest and compute:
```js
const [x, y] = `\
 4060 34000000 00000000 60000000 00000000  4.......\`.......
 4070 7a000000 00000000 1e000000 00000000  z...............
 4080 39000000 00000000 4b000000 00000000  9.......K.......
 4090 79000000 00000000 25000000 00000000  y.......%.......
 40a0 58000000 00000000 14000000 00000000  X...............
 40b0 2b000000 00000000 48000000 00000000  +.......H.......
 40c0 75000000 00000000 56000000 00000000  u.......V.......
 40d0 33000000 00000000 63000000 00000000  3.......c.......
 40e0 68000000 00000000 7d000000 00000000  h.......}.......
 40f0 10000000 00000000 14000000 00000000  ................
 4100 02000000 00000000 3f000000 00000000  ........?.......
 4110 63000000 00000000 7f000000 00000000  c...............
 4120 64000000 00000000 7b000000 00000000  d.......{.......
 4130 0d000000 00000000 05000000 00000000  ................
 4140 70000000 00000000 3a000000 00000000  p.......:.......
 4150 7d000000 00000000 60000000 00000000  }.......\`.......
 4160 0c000000 00000000 2f000000 00000000  ......../.......
 4170 29000000 00000000 4c000000 00000000  ).......L.......
 4180 08000000 00000000 41000000 00000000  ........A.......
 4190 77000000 00000000 1f000000 00000000  w...............
 41a0 1b000000 00000000 61000000 00000000  ........a.......
 41b0 53000000 00000000 35000000 00000000  S.......5.......
 41c0 78000000 00000000 35000000 00000000  x.......5.......
 41d0 3f000000 00000000

 41e0 87ffffff ffffffff d3ffffff ffffffff  ................
 41f0 ccffffff ffffffff b5ffffff ffffffff  ................
 4200 85ffffff ffffffff e0ffffff ffffffff  ................
 4210 c0ffffff ffffffff a1ffffff ffffffff  ................
 4220 f0ffffff ffffffff 83ffffff ffffffff  ................
 4230 e4ffffff ffffffff e8ffffff ffffffff  ................
 4240 e4ffffff ffffffff 9affffff ffffffff  ................
 4250 ffffffff ffffffff f8ffffff ffffffff  ................
 4260 e4ffffff ffffffff ddffffff ffffffff  ................
 4270 8effffff ffffffff daffffff ffffffff  ................
 4280 ccffffff ffffffff 9fffffff ffffffff  ................
 4290 e8ffffff ffffffff e8ffffff ffffffff  ................
 42a0 abffffff ffffffff f7ffffff ffffffff  ................
 42b0 b7ffffff ffffffff a5ffffff ffffffff  ................
 42c0 e9ffffff ffffffff f1ffffff ffffffff  ................
 42d0 ecffffff ffffffff fcffffff ffffffff  ................
 42e0 8affffff ffffffff 8fffffff ffffffff  ................
 42f0 e7ffffff ffffffff ddffffff ffffffff  ................
 4300 84ffffff ffffffff caffffff ffffffff  ................
 4310 faffffff ffffffff 95ffffff ffffffff  ................
 4320 87ffffff ffffffff eaffffff ffffffff  ................
 4330 c5ffffff ffffffff a5ffffff ffffffff  ................
 4340 e9ffffff ffffffff b9ffffff ffffffff  ................
 4350 ffffffff ffffffff`
.split("\n\n").map(a=> // 2-in-1!
    a.match(/.{8} .{8}/g).map(b=> // extract ints
        parseInt(b.slice(0, 2),0x10) // just take first 2 hex digits (byte)
    )
);
String.fromCharCode(...x.map((c,i) =>~(c^y[i])&0xff)); // bitmask because working in bytes
// LLITCTF{Wh0_n33ds_a11_th0sE_f4ncy_1nstructions?
```
Not exactly the flag, but close enough to know what it actually is.

## Flag

`LITCTF{Wh0_n33ds_a11_th0sE_f4ncy_1nstructions?}`
